<template>
<div id="table" class="table-editable">
    <div>
      <table class="table table-bordered table-responsive-xs table-striped" >
        <tr>
          <th style="width: 4%;"></th>
          <th class="text-left" style="">Cantidad</th>
          <th class="text-left" style="width: 50%;">Descripci√≥n</th>
          <th class="text-left" style="">Notas</th>
          <th class="text-left" style="">Descuento</th>
          <th style="width: 16%;" class="text-right">Precio</th>
        </tr>
        <tr v-for="indication in data" v-bind:key="indication.IdTrabajoDetalle">
          <td class="pt-3-half">
            <i class="fa fa-times-circle" v-on:click="deleteRow(indication.IdTrabajoDetalle)" v-if="$attrs.disabled !== true"></i>
          </td>
          <td class="noMargins">
            <input type="text" class="inputInTd">
          </td>
          <td class="noMargins">
            <input type="text" v-model="indication.Descripcion" class="inputInTd" @change="trackChanges($event, indication.IdTrabajoDetalle, 'Descripcion')" :disabled="$attrs.disabled === true">
          </td>
          <td class="noMargins">
            <input type="text" class="inputInTd">
          </td>
          <td class="noMargins">
            <input type="text" class="inputInTd">
          </td>
          <td class="noMargins">
            <input type="text" class="inputInTd text-right" @blur="updatePrice($event, indication.IdTrabajoDetalle)" v-model="indication.Precio" :class="{'bg-danger text-white animated flash': isNotANumber(indication.Precio)}" v-on:keydown="filterJustNumberKeystrokes" @change="trackChanges($event, indication.IdTrabajoDetalle, 'Precio')" :disabled="$attrs.disabled === true">
          </td>
        </tr>
        <tr v-if="$attrs.disabled !== true">
          <td class="pt-3-half"></td>
          <td class="noMargins">
            <input type="text" class="inputInTd">
          </td>
          <td class="noMargins">
            <input type="text" class="inputInTd" ref="newDescripcion" >
          </td>
          <td class="noMargins">
            <input type="text" class="inputInTd">
          </td>
          <td class="noMargins">
            <input type="text" class="inputInTd">
          </td>
          <td class="noMargins">
            <input type="text" class="inputInTd text-right" ref="newPrecio" @blur="addLastRow()" v-on:keydown="filterJustNumberKeystrokes">
          </td>
        </tr>
      </table>
      <div>
        <p class="float-right text-right pr-1" :class="{'d-inline-block text-danger animated shake': sumError}">{{getSum()}}</p>
      </div>
      <!-- <div>
        <h3>Inserted</h3>
        <ul v-for="inserted in insertedRows" :key="inserted.IdTrabajoDetalle">
          <li>{{inserted.IdTrabajoDetalle}}|{{inserted.Descripcion}}|{{inserted.Precio}}</li>
        </ul>
        <h3>Updated</h3>
        <ul v-for="updated in updatedRows" :key="updated.IdTrabajoDetalle">
          <li>{{updated.IdTrabajoDetalle}}|{{updated.Descripcion}}|{{updated.Precio}}</li>
        </ul>
        <h3>Deleted</h3>
        <ul v-for="deleted in deletedRows" :key="deleted.IdTrabajoDetalle">
          <li>{{deleted.IdTrabajoDetalle}}|{{deleted.Descripcion}}|{{deleted.Precio}}</li>
        </ul>
      </div> -->
    </div>
</div>
</template>

<script>

import tablesWithEmptyRowMixin from './TablesWithEmptyRowsMixin'
import { insertWorkIndications, updateWorkIndications, deleteWorkIndications, updatePriceSum } from '../../../../main/dal.js'
import _ from 'lodash'

export default {
  name: 'workIndicationsTable',
  mixins: [tablesWithEmptyRowMixin],
  data () {
    return {
      sumError: false
    }
  },
  methods: {
    // Related with the state and persistence----------------------------------
    addLastRow(){
      if (this.isNotEmpty(this.$refs.newDescripcion.value) || this.isNotEmpty(this.$refs.newPrecio.value)) {
        var newRow = {
          Descripcion: this.$refs.newDescripcion.value,
          IdTrabajoDetalle: this.newIds++,
          Precio: this.$refs.newPrecio.value
          }
        this.data.push(newRow)
        this.insertedRows.push(newRow)
        this.$refs.newDescripcion.value = ''
        this.$refs.newPrecio.value = ''
        this.$emit('input', this.data)
        this.$refs.newDescripcion.focus()
      }
    },
    deleteRow: function (rowId) {
      this.data = _.remove(this.data, function (n) {
        return n.IdTrabajoDetalle !== rowId
      })
      this.$emit('input', this.data)
      if (_.some(this.insertedRows, ['IdTrabajoDetalle', rowId])){
        _.remove(this.insertedRows, ['IdTrabajoDetalle', rowId])
      } else if (_.some(this.updatedRows, ['IdTrabajoDetalle', rowId])){
        _.remove(this.updatedRows, ['IdTrabajoDetalle', rowId])
        this.deletedRows.push({IdTrabajoDetalle: rowId})
      } else {
        this.deletedRows.push({IdTrabajoDetalle: rowId})
      }
    },
    trackChanges(event, rowId, field) {
      //Let's start looking if the changed row is already on the inserted list
      var temp = _.find(this.insertedRows, ['IdTrabajoDetalle', rowId])
      if (this.isNotEmpty(temp)){
        //Just update the inssert with the new value. No more action required.
        temp[field] = event.currentTarget.value
      } else {
        //OK, so we have to update. But maybe this field was already updated. Let's check.
        temp = _.find(this.updatedRows, ['IdTrabajoDetalle', rowId])
        if (this.isNotEmpty(temp)){
          //The row was already updated. Make a cumulative update
          var original = _.find(this.data, ['IdTrabajoDetalle', rowId])
          temp.Precio = original.Precio
          temp.Descripcion = original.Descripcion
        } else {
          //First time updated. So jot it down.
          var original = _.find(this.data, ['IdTrabajoDetalle', rowId])
          this.updatedRows.push(original)
        }
      }
      this.$emit('input', this.data)
    },
    save(masterId){
      _.forEach(this.insertedRows, function(row){
        row.IdTrabajo = masterId
        insertWorkIndications(row)
      })
      _.forEach(this.deletedRows, function(row){
        deleteWorkIndications(row)
      })
      _.forEach(this.updatedRows, function(row){
        updateWorkIndications(row)
      })
      updatePriceSum(masterId)
      this.insertedRows = []
      this.deletedRows = []
      this.updatedRows = []
    },
    // Other methods (specific)------------------------------------------------
    getSum: function () {
      try {
        var sum = _.sumBy(this.data, function(n) {
          var temp = parseFloat(n.Precio)
          if (isNaN(temp)){
            throw 'NaN'
          } else {
            return temp
          }
        })
        this.sumError = false
        return 'Total: ' + this.moneyFormatter.format(sum)
      }
      catch(err){
        this.sumError = true
        return 'Error en los datos a sumar'
      }
    },
    updatePrice(event, id) {
      var elementInArray = _.find(this.data, ['IdTrabajoDetalle', id])
      if (this.isEmpty(event.srcElement.value)) {
        elementInArray.Precio = 0
      } else {
        elementInArray.Precio =  event.srcElement.value
      }
      this.$emit('input', this.data)
    },
    filterJustNumberKeystrokes(event){
      if (!(event.key === '0' || event.key === '1' || event.key === '2' ||
        event.key === '3' || event.key === '4' || event.key === '5' ||
        event.key === '6' || event.key === '7' || event.key === '8' ||
        event.key === '9' || event.key === '.' || event.key === 'ArrowLeft' ||
        event.key === 'ArrowRight' || event.key === 'Home' || event.key === 'End' ||
        event.key === '-' || (event.key === 'c' && event.ctrlKey === true) ||
        event.key === 'Delete' || (event.key === 'v' && event.ctrlKey === true) ||
        event.key === 'Backspace' || event.key === 'Tab' || event.key === 'Enter'
      ))
        event.preventDefault()
    },
    canDisplayDropdown: function() {
      //TODO
      return false
    },
  }
}
</script>
